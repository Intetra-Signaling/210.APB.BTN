// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

// Default mock implementation of the API callbacks

#include "mongoose_glue.h"
#include "Alarms.h"
#include "esp_adc/adc_continuous.h"
#include "esp_system.h"
#include "main.h"
#include "FlashConfig.h"
#include "SD_SPI.h"
#include "Thread.h"
#include "mongoose.h"
#include "wifi.h"
#include "esp_task_wdt.h"
#include "esp_task_wdt.h"
#include "MichADCRead.h"
#include "esp_task_wdt.h"


static uint64_t s_action_timeout_reboot;  // Time when reboot ends
extern uint32_t g_adcAverage;
bool TestMode = false;
#define NOISE_LEVEL_HISTORY_SIZE 15 // Re-define or include common header
extern int noise_level_history[NOISE_LEVEL_HISTORY_SIZE];
bool DefConfigFlashWrite = false;
bool Alt1ConfigFlashWrite = false;
bool Alt2ConfigFlashWrite = false;
bool Alt3ConfigFlashWrite = false;


bool StartWriteConfigs = false;
bool StopIO_Threat = false;
bool ConfigurationPageRequest = false;
bool SettingsPageSystemInfoRequest = false;
bool SettingsPageWifiSettingsRequest = false;
bool AudioConfigurationPageRequest = false;
bool CalendarPageRequest = false;
bool SettingsPageLoginInfoChange = false;
bool isClearSDFiles = false;
bool NetworkSettingsPageRequest = false;
extern volatile float volume_factor;
extern bool StopPlayWav;

char admin_name[30] = "admin"; // Admin name and password is stucked in here.
char admin_password[30] = "!ntetrAPB_5";

struct security s_security;
bool isOtaDone = false;



// Authenticate user/password. Return access level for the authenticated user:
//   0 - authentication error
//   1,2,3... - authentication success. Higher levels are more privileged than lower
int glue_authenticate(const char *user, const char *pass) {
  int level = 0; // Authentication failure
  if (strcmp(user, admin_name) == 0 && strcmp(pass, admin_password) == 0) {
    level = 7;  // Administrator
  } else if (strcmp(user, s_security.userName) == 0 && strcmp(pass, s_security.password) == 0) {
    level = 7;  //3;  // Ordinary dude
  }
  return level;
}


static uint64_t s_action_timeout_reboot;  // Time when reboot ends
bool glue_check_reboot(void) {
  return s_action_timeout_reboot > mg_now(); // Return true if reboot is in progress
}
void glue_start_reboot(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_reboot = mg_now() + 1000; // Start reboot, finish after 1 second
}

static uint64_t s_action_timeout_reformat;  // Time when reformat ends
bool glue_check_reformat(void) {
  return s_action_timeout_reformat > mg_now(); // Return true if reformat is in progress
}
void glue_start_reformat(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_reformat = mg_now() + 1000; // Start reformat, finish after 1 second
}

void *glue_upload_open_file_upload(char *file_name, size_t total_size) {
  char path[128], *p = NULL;
  FILE *fp = NULL;
  if ((p = strrchr(file_name, '/')) == NULL) p = file_name;
  mg_snprintf(path, sizeof(path), "/sdcard/%s", p);
#if MG_ENABLE_POSIX_FS
  fp = fopen(path, "w+b");
#endif
  MG_DEBUG(("opening [%s] size %lu, fp %p", path, total_size, fp));
  return fp;
}
bool glue_upload_close_file_upload(void *fp) {
  MG_DEBUG(("closing %p", fp));
#if MG_ENABLE_POSIX_FS
  return fclose((FILE *) fp) == 0;
#else
  return false;
#endif
}
bool glue_upload_write_file_upload(void *fp, void *buf, size_t len) {
  MG_DEBUG(("writing fp %p %p %lu bytes", fp, buf, len));
#if MG_ENABLE_POSIX_FS
  return fwrite(buf, 1, len, (FILE *) fp) == len;
#else
  return false;
#endif
}

struct deleteFile s_deleteFile = {""};
void glue_get_deleteFile(struct deleteFile *data) {
  *data = s_deleteFile;  // Sync with your device
}

bool isDeleteFile = false;


void glue_set_deleteFile(struct deleteFile *data) {
  s_deleteFile = *data; // Sync with your device
  char full_file_path[64] = {0};  // Adjust size if needed
  // Construct full path
  snprintf(full_file_path, sizeof(full_file_path), "/sdcard/%s", s_deleteFile.fileName);
  printf("Sayim oynatiliyor: %s\n", full_file_path);
  
  isDeleteFile = DeleteSDFile(full_file_path);
  
  
  if(isDeleteFile == false)
  {
	  printf("Dosya silinemedi: %s\n", full_file_path);
	  
  } else {
      printf("Dosya basariyla silindi: %s\n", full_file_path);
  }
  
}

static struct state s_state = {42, 27, 67, 10, "1.0.0", true, false, 83};
void glue_get_state(struct state *data) {
  *data = s_state;  // Sync with your device
}

void glue_reply_loglevels(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  const char *value = "[\"disabled\",\"error\",\"info\",\"debug\",\"verbose\"]";
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", value);
}
void glue_reply_events(struct mg_connection *c, struct mg_http_message *hm) {
    const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
    
    uint8_t log_count = 0;
    const AlarmJsonLog_t *logs = Alarm_GetJsonStructLogs(&log_count);
    
    // Gerekli buffer boyutunu hesapla
    size_t needed_size = 3; // [] ve null terminator
    for (uint8_t i = 0; i < log_count; i++) {
        needed_size += 50; // Temel JSON yapısı
        needed_size += strlen(logs[i].date);
        needed_size += strlen(logs[i].message);
    }
    
    char *json_buffer = malloc(needed_size);
    if (!json_buffer) {
        mg_http_reply(c, 500, headers, "{\"error\":\"Memory allocation failed\"}\n");
        return;
    }
    
    char *ptr = json_buffer;
    ptr += sprintf(ptr, "[");
    
    for (uint8_t i = 0; i < log_count; i++) {
        const char *level_str;
        switch(logs[i].level) {
            case LOG_LEVEL_INFO: level_str = "INFO"; break;
            case LOG_LEVEL_WARN: level_str = "WARN"; break;
            case LOG_LEVEL_ERROR: level_str = "ERROR"; break;
            default: level_str = "UNKNOWN"; break;
        }
        
        ptr += sprintf(ptr, "%s{\"date\":\"%s\",\"level\":\"%s\",\"message\":\"%s\"}",
                      (i > 0) ? "," : "",
                      logs[i].date,
                      level_str,
                      logs[i].message);
    }
    
    ptr += sprintf(ptr, "]");
    
    (void) hm;
    mg_http_reply(c, 200, headers, "%s\n", json_buffer);
    free(json_buffer);
}
void glue_reply_download(struct mg_connection *c, struct mg_http_message *hm) {
  char file_name[128], path[256], header[256];
  struct mg_str *qs = &hm->query;

  // Extract the "file" query parameter
  mg_http_get_var(qs, "file", file_name, sizeof(file_name));
  //strcpy(file_name ,"foo.txt");
  if (file_name[0] == '\0') {
    mg_http_reply(c, 400, "Content-Type: text/plain\r\n", "Missing 'file' parameter\n");
    return;
  }

  // Build full path on SD card
  mg_snprintf(path, sizeof(path), "/sdcard/%s", file_name);

#if MG_ENABLE_POSIX_FS
  // Check file existence
  FILE *fp = fopen(path, "rb");
  if (fp == NULL) {
    mg_http_reply(c, 404, "Content-Type: text/plain\r\n", "File not found\n");
    return;
  }
  fclose(fp);
#endif

  // Set headers to force download
  mg_snprintf(header, sizeof(header), "Content-Disposition: attachment; filename=\"%s\"\r\n", file_name);
  struct mg_http_serve_opts opts = { .extra_headers = header };

  // Serve the file content
  mg_http_serve_file(c, hm, path, &opts);
}

 struct sunday s_sunday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_sunday(struct sunday *data) {
  *data = s_sunday;  // Sync with your device
}
void glue_set_sunday(struct sunday *data) {
  s_sunday = *data; // Sync with your device
   printf("1\n");
}

 struct monday s_monday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_monday(struct monday *data) {
  *data = s_monday;  // Sync with your device
}
void glue_set_monday(struct monday *data) {
  s_monday = *data; // Sync with your device
   printf("2\n");
}

 struct tuesday s_tuesday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_tuesday(struct tuesday *data) {
  *data = s_tuesday;  // Sync with your device
}
void glue_set_tuesday(struct tuesday *data) {
  s_tuesday = *data; // Sync with your device
   printf("3\n");
}

 struct wednesday s_wednesday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_wednesday(struct wednesday *data) {
  *data = s_wednesday;  // Sync with your device
   
}
void glue_set_wednesday(struct wednesday *data) {
  s_wednesday = *data; // Sync with your device
 printf("4\n");
 }

 struct thursday s_thursday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_thursday(struct thursday *data) {
  *data = s_thursday;  // Sync with your device
}
void glue_set_thursday(struct thursday *data) {
  s_thursday = *data; // Sync with your device
   printf("5\n");
}

struct friday s_friday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_friday(struct friday *data) {
  *data = s_friday;  // Sync with your device
}
void glue_set_friday(struct friday *data) {
  s_friday = *data; // Sync with your device
   printf("6\n");
}

 struct saturday s_saturday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
void glue_get_saturday(struct saturday *data) {
  *data = s_saturday;  // Sync with your device
}
void glue_set_saturday(struct saturday *data) {
  s_saturday = *data; // Sync with your device
  printf("7\n");
  
}

struct holidays s_holidays = {"", "", "", "", "", "", "", "", "", ""};
void glue_get_holidays(struct holidays *data) {
  *data = s_holidays;  // Sync with your device
}
void glue_set_holidays(struct holidays *data) {
  s_holidays = *data; // Sync with your device
  CalendarPageRequest = true;
  printf("Holiday1 adi: %s\n", s_holidays.holiday1);
  printf("CalendarPageRequest=true\n");
  StopIO_Threat = true;
}


struct network_settings s_network_settings;
void glue_get_network_settings(struct network_settings *data) {
  *data = s_network_settings;  // Sync with your device
}
void glue_set_network_settings(struct network_settings *data) {
    s_network_settings = *data; // Sync with your device
  
    // Define edilmiş default IP bilgilerini güncelle
    snprintf(s_network_settings.ip_address, sizeof(s_network_settings.ip_address), DEVICE_WIFI_AP_IP);
    snprintf(s_network_settings.gw_address, sizeof(s_network_settings.gw_address), DEVICE_WIFI_AP_GATEWAY);
    snprintf(s_network_settings.netmask, sizeof(s_network_settings.netmask), DEVICE_WIFI_AP_NETMASK);

    // Varsayılan olarak DHCP'yi kapat
    s_network_settings.dhcp = false;
    
      // Flash’a yazma task’ını tetikle
    NetworkSettingsPageRequest = true;
    StopIO_Threat = true;

    printf("Network ayarlari guncellendi: ip=%s, gw=%s, netmask=%s, dhcp=%d\n",
            s_network_settings.ip_address,
            s_network_settings.gw_address,
            s_network_settings.netmask,
            s_network_settings.dhcp);
           
}

void *glue_ota_begin_firmware_update(char *file_name, size_t total_size) {
  bool ok = mg_ota_begin(total_size);
  MG_DEBUG(("%s size %lu, ok: %d", file_name, total_size, ok));
  return ok ? (void *) 1 : NULL;
}
bool glue_ota_end_firmware_update(void *context) {
  mg_timer_add(&g_mgr, 500, 0, (void (*)(void *)) (void *) mg_ota_end, context);
  isOtaDone = true;
  return true;
}
bool glue_ota_write_firmware_update(void *context, void *buf, size_t len) {
  MG_DEBUG(("ctx: %p %p/%lu", context, buf, len));
  return mg_ota_write(buf, len);
}

static struct reset s_reset = {false};
void glue_get_reset(struct reset *data) {
  *data = s_reset;  // Sync with your device
}


void glue_set_reset(struct reset *data) {
  s_reset = *data; // Sync with your device
  ClearAllSDFiles();
  ClearConfigsFromFlash();
  esp_restart();
}

void glue_get_security(struct security *data) {
  *data = s_security;  // Sync with your devic
}


void glue_set_security(struct security *data) {
  s_security = *data; // Sync with your device
  SettingsPageLoginInfoChange = true;
  printf("SettingsPageLoginInfoChange=true\n");
  StopIO_Threat = true;
}

static struct clock_settings s_clock_settings = {false, "192.192.192.192", 1, "GMT+03", false, "30.05.2025 13:45:00", false};
void glue_get_clock_settings(struct clock_settings *data) {
  *data = s_clock_settings;  // Sync with your device
}
void glue_set_clock_settings(struct clock_settings *data) {
  s_clock_settings = *data; // Sync with your device
}

struct systemInfo s_systemInfo = {"MyDevice", "MyComment", APPLICATON_VERSION};
void glue_get_systemInfo(struct systemInfo *data) {
  *data = s_systemInfo;  // Sync with your device
}
void glue_set_systemInfo(struct systemInfo *data) {
  s_systemInfo = *data; // Sync with your device
  SettingsPageSystemInfoRequest = true;
  printf("SettingsPageSystemInfoRequest=true\n");
  StopIO_Threat = true;
  printf(("systemInfo\n"));
}

 struct wifiSettings s_wifiSettings = {"ESP32_AP_"};
void glue_get_wifiSettings(struct wifiSettings *data) {
  *data = s_wifiSettings;  // Sync with your device
}
void glue_set_wifiSettings(struct wifiSettings *data) {
  s_wifiSettings = *data; // Sync with your device
  //wifi_deinit_ap();
  SettingsPageWifiSettingsRequest = true;
  printf("SettingsPageWifiSettingsRequest=true\n");
  StopIO_Threat = true;
}

struct defaultConfiguration s_defaultConfiguration = {true, "", 0, 100, false, true, "", "", 0, 0, 100, true, "", 0, 100, 10, 1, ""};
void glue_get_defaultConfiguration(struct defaultConfiguration *data) {
  *data = s_defaultConfiguration;  // Sync with your device
}

void glue_set_defaultConfiguration(struct defaultConfiguration *data) {
s_defaultConfiguration = *data; // Sync with your device
printf(("1\n")); 
}

struct alt1Configuration s_alt1Configuration = {true, "", 0, 100, false, true, "", "", 0, 0, 100, true, "", 0, 100, 10, 1, ""};
void glue_get_alt1Configuration(struct alt1Configuration *data) {
  *data = s_alt1Configuration;  // Sync with your device
}

void glue_set_alt1Configuration(struct alt1Configuration *data) {
s_alt1Configuration = *data; // Sync with your device
printf("Alt1ConfigFlashWrite=true\n");
Alt1ConfigFlashWrite = true;
printf(("2\n"));
}

struct alt2Configuration s_alt2Configuration = {true, "", 0, 100, false, true, "", "", 0, 0, 100, true, "", 0, 100, 10, 1, ""};
void glue_get_alt2Configuration(struct alt2Configuration *data) {
  *data = s_alt2Configuration;  // Sync with your device
}
void glue_set_alt2Configuration(struct alt2Configuration *data) {
s_alt2Configuration = *data; // Sync with your device
Alt2ConfigFlashWrite = true;
printf("Alt2ConfigFlashWrite=true\n");
printf(("3\n"));
}

 struct alt3Configuration s_alt3Configuration = {true, "", 0, 100, false, true, "", "", 0, 0, 100, 42, "", 0, 100, 10, 1, ""};
void glue_get_alt3Configuration(struct alt3Configuration *data) {
  *data = s_alt3Configuration;  // Sync with your device
}

void glue_set_alt3Configuration(struct alt3Configuration *data) {
s_alt3Configuration = *data;
  ConfigurationPageRequest = true;
  printf("ConfigurationPageRequest=true\n");
  StopIO_Threat = true; 
}

void glue_reply_directory(struct mg_connection *c, struct mg_http_message *hm) {
    const char *headers = "Cache-Control: no-cache\r\n"
                         "Content-Type: application/json\r\n"
                         "Access-Control-Allow-Origin: *\r\n";

    // İlk geçiş: Gerekli buffer boyutunu hesapla
    size_t needed_size = 3; // "[]\0" için temel boyut
    
    // Geçici buffer kullanarak boyut hesapla
    char temp_buffer[256];
    DIR *dir = opendir(MOUNT_POINT);
    if (dir == NULL) {
        mg_http_reply(c, 500, headers, "{\"error\":\"Failed to open directory\"}\n");
        return;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        char *ext = strrchr(entry->d_name, '.');
        if (ext && strcasecmp(ext, ".wav") == 0) {
            // Her giriş için tahmini boyut
            needed_size += 50 + strlen(entry->d_name) + 20;
        }
    }
    closedir(dir);

    // Buffer ayır
    char *json_buffer = malloc(needed_size);
    if (!json_buffer) {
        mg_http_reply(c, 500, headers, "{\"error\":\"Memory allocation failed\"}\n");
        return;
    }
    // CheckSDFiles fonksiyonunu çağır
    CheckSDFiles(json_buffer, needed_size);
    // Yanıtı gönder
    mg_http_reply(c, 200, headers, "%s\n", json_buffer);
    free(json_buffer);
    (void)hm; // Kullanılmayan parametre uyarısını önle
}

struct playSound s_playSound = {"", 50};
void glue_get_playSound(struct playSound *data) {
  *data = s_playSound;  // Sync with your device 
}
void glue_set_playSound(struct playSound *data) {
  s_playSound = *data; // Sync with your device
  StopPlayWav = true;
  TestMode = true;

  volume_factor = (float)s_playSound.soundLevel * (0.55f / 100.0f);
  printf("volume_factor degeri: %.2f\n", volume_factor);
  printf("Volume degeri: %d\n", s_playSound.soundLevel);
  printf("Dosya adi: %s\n", s_playSound.fileName);
  //stopTestMode();
}


struct audioConfig s_audioConfig;
void glue_get_audioConfig(struct audioConfig *data) {
  *data = s_audioConfig;  // Sync with your device
}
void glue_set_audioConfig(struct audioConfig *data) {
   s_audioConfig = *data; // Sync with your device
//    // Print all structure members
//    printf("sound30: %s\n", s_audioConfig.sound30);
//    printf("sound29: %s\n", s_audioConfig.sound29);
//    printf("sound28: %s\n", s_audioConfig.sound28);
//    printf("sound27: %s\n", s_audioConfig.sound27);
//    printf("sound26: %s\n", s_audioConfig.sound26);
//    printf("sound25: %s\n", s_audioConfig.sound25);
//    printf("sound24: %s\n", s_audioConfig.sound24);
//    printf("sound23: %s\n", s_audioConfig.sound23);
//    printf("sound22: %s\n", s_audioConfig.sound22);
//    printf("sound21: %s\n", s_audioConfig.sound21);
//    printf("sound20: %s\n", s_audioConfig.sound20);
//    printf("sound19: %s\n", s_audioConfig.sound19);
//    printf("sound18: %s\n", s_audioConfig.sound18);
//    printf("sound17: %s\n", s_audioConfig.sound17);
//    printf("sound16: %s\n", s_audioConfig.sound16);
//    printf("sound15: %s\n", s_audioConfig.sound15);
//    printf("sound14: %s\n", s_audioConfig.sound14);
//    printf("sound13: %s\n", s_audioConfig.sound13);
//    printf("sound12: %s\n", s_audioConfig.sound12);
//    printf("sound11: %s\n", s_audioConfig.sound11);
//    printf("sound10: %s\n", s_audioConfig.sound10);
//    printf("sound9: %s\n", s_audioConfig.sound9);
//    printf("sound8: %s\n", s_audioConfig.sound8);
//    printf("sound7: %s\n", s_audioConfig.sound7);
//    printf("sound6: %s\n", s_audioConfig.sound6);
//    printf("sound5: %s\n", s_audioConfig.sound5);
//    printf("sound4: %s\n", s_audioConfig.sound4);
//    printf("sound3: %s\n", s_audioConfig.sound3);
//    printf("sound2: %s\n", s_audioConfig.sound2);
//    printf("sound1: %s\n", s_audioConfig.sound1);
   printf("AudioConfigurationPageRequest=true\n");
   AudioConfigurationPageRequest = true;
   StopIO_Threat = true;
}

 struct currentTime s_currentTime = {"19.07.2025", "10:10:10"};
void glue_get_currentTime(struct currentTime *data) {
	// DeviceTime'dan tarih ve saati formatla
  snprintf(s_currentTime.date, sizeof(s_currentTime.date), 
           "%02d.%02d.20%02d", 
           DeviceTime.day, DeviceTime.month, DeviceTime.year);

  snprintf(s_currentTime.time, sizeof(s_currentTime.time), 
           "%02d:%02d:%02d", 
           DeviceTime.hours, DeviceTime.minutes, DeviceTime.seconds);

  *data = s_currentTime;  // Sync with your device
  
}
void glue_set_currentTime(struct currentTime *data) {
    s_currentTime = *data;  // JSON'dan gelen zamanı kaydet

    // s_currentTime -> DeviceTime aktar
    uint16_t full_year;
	sscanf(s_currentTime.date, "%hhu.%hhu.%hu", &DeviceTime.day, &DeviceTime.month, &full_year);
	DeviceTime.year = full_year % 100;  // 2025 -> 25

    sscanf(s_currentTime.time, "%hhu:%hhu:%hhu", &DeviceTime.hours, &DeviceTime.minutes, &DeviceTime.seconds);

     // Otomatik olarak haftanın gününü hesapla
    struct tm t = {0};
    t.tm_year = full_year - 1900; // tm_year 1900'den beri geçen yılları tutar
    t.tm_mon = DeviceTime.month - 1; // tm_mon 0-11 arasındadır
    t.tm_mday = DeviceTime.day;
    // mktime() fonksiyonu tm yapısını doldurur, buna tm_wday (haftanın günü) de dahildir.
    mktime(&t); 
    // Haftanın gününü RTC formatına çevir (0: Pazar, 1: Pazartesi...)
    DeviceTime.day_of_week = t.tm_wday; 
    
    // RTC'ye yaz
    esp_err_t result = mcp7940n_set_time(&DeviceTime);
    if (result != ESP_OK) {
        Alarm_Log("glue_set_currentTime: RTC ayarlanamadi", NULL);
    }
}
void glue_reply_noiseLevel(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  char response_buffer[256]; // Ensure sufficient size
  char *ptr = response_buffer;
  size_t remaining_size = sizeof(response_buffer);
  int written_chars; 
      // JSON array start
      written_chars = snprintf(ptr, remaining_size, "[");
      if (written_chars < 0 || (size_t)written_chars >= remaining_size) {
          mg_http_reply(c, 200, headers, "[]\n");
           return;
      }
      ptr += written_chars;
      remaining_size -= written_chars;

      // Iterate through the history array and build JSON
      for (int i = 0; i < NOISE_LEVEL_HISTORY_SIZE; i++) {
          if (i > 0) {
              written_chars = snprintf(ptr, remaining_size, ",");
              if (written_chars < 0 || (size_t)written_chars >= remaining_size) break;
              ptr += written_chars;
              remaining_size -= written_chars;
          }

          written_chars = snprintf(ptr, remaining_size, "\"%d\"", noise_level_history[i]);
          if (written_chars < 0 || (size_t)written_chars >= remaining_size) break;
          ptr += written_chars;
          remaining_size -= written_chars;
      }

      // JSON array end
      if (remaining_size > 0) {
          snprintf(ptr, remaining_size, "]");
      } else {
          // Fallback for full buffer: try to terminate correctly
          if (sizeof(response_buffer) > 0) {
              if (ptr > response_buffer && *(ptr - 1) == ',') {
                  *(ptr - 1) = ']';
                  *ptr = '\0';
              } else {
                  response_buffer[sizeof(response_buffer) - 1] = '\0';
              }
          }
      } 
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", response_buffer);
}


struct volume s_volume;
void glue_get_volume(struct volume *data) {
s_volume.volume = (int)((volume_factor / 0.55f) * 150.0f + 0.5f);
*data = s_volume;  // Sync with your device
}
void glue_set_volume(struct volume *data) {
  s_volume = *data; // Sync with your device
}

 struct deviceStatus s_deviceStatus = {0, 0, 0};
void glue_get_deviceStatus(struct deviceStatus *data) {
  *data = s_deviceStatus;  // Sync with your device
}
void glue_set_deviceStatus(struct deviceStatus *data) {
  s_deviceStatus = *data; // Sync with your device
}


