/*
 * SPDX-FileCopyrightText: 2024 Cesanta Software Limited
 * SPDX-License-Identifier: GPL-2.0-only or commercial
 * Generated by Mongoose Wizard, https://mongoose.ws/wizard/
 * Default mock implementation of the API callbacks
 *
 *  mongoose_glue.c
 *
 *  Created on: 30 Nis 2025
 *
 * @file
 * @brief Provides the main interface and callback implementations for Mongoose web server integration
 *        in embedded systems and IoT devices.
 *
 * This module contains all glue functions and HTTP callback implementations for device configuration,
 * OTA updates, system information, security, audio, and other features. It acts as a bridge between
 * device-specific logic and the Mongoose web server, enabling REST API and web interface functionality.
 * 
 * The design follows the standard INTETRA format for modular device software development, including
 * copyright, versioning, and documentation for maintainability.
 *
 * @company    INTETRA
 * @version    v.0.0.0.1
 * @creator    Enis OKATAN
 * @update     Mete SEPETCIOGLU
 *
 * Example usage and structure follows other INTETRA modules:
 * - All API glue functions for device features (clock, security, systemInfo, audio, etc.)
 * - HTTP reply and request handlers for REST endpoints
 * - Integration points for Mongoose event loop and mg_connection
 *
 */
 
 
#include "mongoose_glue.h"
#include "Alarms.h"
#include "esp_adc/adc_continuous.h"
#include "esp_system.h"
#include "main.h"
#include "FlashConfig.h"
#include "SD_SPI.h"
#include "Thread.h"
#include "mongoose.h"
#include "wifi.h"
#include "esp_task_wdt.h"
#include "esp_task_wdt.h"
#include "MichADCRead.h"
#include "esp_task_wdt.h"


static uint64_t s_action_timeout_reboot;  // Time when reboot ends
extern uint32_t g_adcAverage;
bool TestMode = false;
#define NOISE_LEVEL_HISTORY_SIZE 15 // Re-define or include common header
extern int noise_level_history[NOISE_LEVEL_HISTORY_SIZE];
bool DefConfigFlashWrite = false;
bool Alt1ConfigFlashWrite = false;
bool Alt2ConfigFlashWrite = false;
bool Alt3ConfigFlashWrite = false;


bool StartWriteConfigs = false;
bool StopIO_Threat = false;
bool ConfigurationPageRequest = false;
bool SettingsPageSystemInfoRequest = false;
bool SettingsPageWifiSettingsRequest = false;
bool AudioConfigurationPageRequest = false;
bool CalendarPageRequest = false;
bool SettingsPageLoginInfoChange = false;
bool isClearSDFiles = false;
bool NetworkSettingsPageRequest = false;
bool isDeleteFile = false;

extern volatile float volume_factor;
extern bool StopPlayWav;

char admin_name[30] = "admin"; // Admin name and password is stucked in here.
char admin_password[30] = "!ntetrAPB_5";

struct security s_security;
bool isOtaDone = false;

struct deviceStatus s_deviceStatus = {0, 0, 0};
struct volume s_volume;
static uint64_t s_action_timeout_reboot;  // Time when reboot ends
static struct state s_state = {42, 27, 67, 10, "1.0.0", true, false, 83};
struct sunday    s_sunday    = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct monday    s_monday    = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct tuesday   s_tuesday   = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct wednesday s_wednesday = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct thursday  s_thursday  = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct friday    s_friday    = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct saturday  s_saturday  = {"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};
struct holidays s_holidays = {"", "", "", "", "", "", "", "", "", ""};
struct network_settings s_network_settings;
static struct reset s_reset = {false};
static struct clock_settings s_clock_settings = {false, "192.192.192.192", 1, "GMT+03", false, "30.05.2025 13:45:00", false};
struct currentTime s_currentTime = {"19.07.2025", "10:10:10"};
struct playSound s_playSound = {"", 50};
struct defaultConfiguration s_defaultConfiguration = {true, "", 0, 100, false, true, "", "", 0, 0, 100, true, "", 0, 100, 10, 1, ""};
struct alt1Configuration    s_alt1Configuration    = {true, "", 0, 100, false, true, "", "", 0, 0, 100, true, "", 0, 100, 10, 1, ""};
struct alt2Configuration    s_alt2Configuration    = {true, "", 0, 100, false, true, "", "", 0, 0, 100, true, "", 0, 100, 10, 1, ""};
struct alt3Configuration    s_alt3Configuration    = {true, "", 0, 100, false, true, "", "", 0, 0, 100, 42, "", 0, 100, 10, 1, ""};
static uint64_t s_action_timeout_reformat;  // Time when reformat ends
struct deleteFile s_deleteFile = {""};
struct systemInfo s_systemInfo = {"MyDevice", "MyComment", APPLICATON_VERSION};
struct wifiSettings s_wifiSettings = {"ESP32_AP_"};
struct audioConfig s_audioConfig;



/**
 * @brief Authenticate user credentials and return access level.
 *
 * Compares the provided username and password against stored administrator and user credentials.
 * Returns an access level for the authenticated user:
 *   0 - authentication error
 *   1, 2, 3... - authentication success (higher levels are more privileged)
 *
 * @param[in] user Username string to authenticate.
 * @param[in] pass Password string to authenticate.
 * @return int Access level (0 for failure, higher values for success).
 */
int glue_authenticate(const char *user, const char *pass) {
  int level = 0; // Authentication failure
  if (strcmp(user, admin_name) == 0 && strcmp(pass, admin_password) == 0) {
    level = 7;  // Administrator
  } else if (strcmp(user, s_security.userName) == 0 && strcmp(pass, s_security.password) == 0) {
    level = 7;  //3;  // Ordinary dude
  }
  return level;
}



/**
 * @brief Checks if a reboot action is currently in progress.
 *
 * Returns true if the reboot timeout is greater than the current time (mg_now),
 * indicating that a reboot is in progress.
 *
 * @return bool True if reboot is in progress, false otherwise.
 */
bool glue_check_reboot(void) {
  return s_action_timeout_reboot > mg_now(); // Return true if reboot is in progress
}



/**
 * @brief Initiates a reboot action with a 1-second timeout.
 *
 * Sets the reboot timeout to current time + 1000ms, indicating that a reboot is in progress.
 * Logs the passed parameters for debugging purposes.
 *
 * @param[in] params Parameters passed to the reboot function.
 */
void glue_start_reboot(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_reboot = mg_now() + 1000; // Start reboot, finish after 1 second
}



/**
 * @brief Checks if a reformat action is currently in progress.
 *
 * Returns true if the reformat timeout is greater than the current time (mg_now),
 * indicating that a reformat operation is in progress.
 *
 * @return bool True if reformat is in progress, false otherwise.
 */

bool glue_check_reformat(void) {
  return s_action_timeout_reformat > mg_now(); // Return true if reformat is in progress
}



/**
 * @brief Initiates a reformat action with a 1-second timeout.
 *
 * Sets the reformat timeout to current time + 1000ms, indicating that a reformat operation is in progress.
 * Logs the passed parameters for debugging purposes.
 *
 * @param[in] params Parameters passed to the reformat function.
 */
void glue_start_reformat(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_reformat = mg_now() + 1000; // Start reformat, finish after 1 second
}



/**
 * @brief Opens a file for upload on the SD card filesystem.
 *
 * This function constructs the full path for the given file name (placing it under "/sdcard/"),
 * and opens it in binary write mode. It supports POSIX file systems. The function logs the operation
 * and returns a file pointer to be used for subsequent file operations.
 *
 * @param[in] file_name Name of the file to be uploaded (can include path).
 * @param[in] total_size Total size of the file to be uploaded (for logging purposes).
 * @return void* File pointer (FILE*) if successful, NULL otherwise.
 */
void *glue_upload_open_file_upload(char *file_name, size_t total_size) {
  char path[128], *p = NULL;
  FILE *fp = NULL;
  if ((p = strrchr(file_name, '/')) == NULL) p = file_name;
  mg_snprintf(path, sizeof(path), "/sdcard/%s", p);
#if MG_ENABLE_POSIX_FS
  fp = fopen(path, "w+b");
#endif
  MG_DEBUG(("opening [%s] size %lu, fp %p", path, total_size, fp));
  return fp;
}



/**
 * @brief Closes a file previously opened for upload.
 *
 * This function closes the given file pointer if using POSIX file system.
 * Logs the file pointer for debugging.
 *
 * @param[in] fp File pointer to close.
 * @return bool True if the file was closed successfully, false otherwise.
 */
bool glue_upload_close_file_upload(void *fp) {
  MG_DEBUG(("closing %p", fp));
#if MG_ENABLE_POSIX_FS
  return fclose((FILE *) fp) == 0;
#else
  return false;
#endif
}



/**
 * @brief Writes a buffer to a file during upload.
 *
 * Writes the specified number of bytes from the buffer to the file pointer, if using POSIX file system.
 * Logs the operation for debugging.
 *
 * @param[in] fp   File pointer to write to.
 * @param[in] buf  Pointer to data buffer to write.
 * @param[in] len  Number of bytes to write from buffer.
 * @return bool True if all bytes are written successfully, false otherwise.
 */
bool glue_upload_write_file_upload(void *fp, void *buf, size_t len) {
  MG_DEBUG(("writing fp %p %p %lu bytes", fp, buf, len));
#if MG_ENABLE_POSIX_FS
  return fwrite(buf, 1, len, (FILE *) fp) == len;
#else
  return false;
#endif
}



/**
 * @brief Retrieves the current deleteFile structure.
 *
 * Copies the internal deleteFile structure to the provided pointer,
 * allowing synchronization with the device.
 *
 * @param[out] data Pointer to a deleteFile structure to receive the data.
 */
void glue_get_deleteFile(struct deleteFile *data) {
  *data = s_deleteFile;  // Sync with your device
}




/**
 * @brief Sets the deleteFile structure and attempts to delete the specified file from SD card.
 *
 * Copies the provided deleteFile structure to the internal variable, constructs the full SD card path,
 * and attempts to delete the file using DeleteSDFile. Prints the result of the operation.
 *
 * @param[in] data Pointer to a deleteFile structure containing file information.
 */
void glue_set_deleteFile(struct deleteFile *data) {
  s_deleteFile = *data; // Sync with your device
  char full_file_path[64] = {0};  // Adjust size if needed
  // Construct full path
  snprintf(full_file_path, sizeof(full_file_path), "/sdcard/%s", s_deleteFile.fileName);
  printf("Sayim oynatiliyor: %s\n", full_file_path);
  
  isDeleteFile = DeleteSDFile(full_file_path);
  
  if(isDeleteFile == false)
  {
	  printf("Dosya silinemedi: %s\n", full_file_path);
	  
  } else {
      printf("Dosya basariyla silindi: %s\n", full_file_path);
  }
  
}


/**
 * @brief Retrieves the current state structure.
 *
 * Copies the internal state structure to the provided pointer,
 * allowing synchronization with the device.
 *
 * @param[out] data Pointer to a state structure to receive the data.
 */
void glue_get_state(struct state *data) {
  *data = s_state;  // Sync with your device
}



/**
 * @brief Replies with available log levels in JSON format over HTTP.
 *
 * Sends a JSON array of available log levels as an HTTP response.
 *
 * @param[in] c  Pointer to the HTTP connection.
 * @param[in] hm Pointer to the HTTP message (unused).
 */
void glue_reply_loglevels(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  const char *value = "[\"disabled\",\"error\",\"info\",\"debug\",\"verbose\"]";
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", value);
}


/**
 * @brief Replies with log events in JSON format over HTTP.
 *
 * Retrieves log entries using Alarm_GetJsonStructLogs, constructs a JSON array,
 * and sends it as an HTTP response. Handles memory allocation error gracefully.
 *
 * @param[in] c  Pointer to the HTTP connection.
 * @param[in] hm Pointer to the HTTP message (unused).
 */
void glue_reply_events(struct mg_connection *c, struct mg_http_message *hm) {
    const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
    
    uint8_t log_count = 0;
    const AlarmJsonLog_t *logs = Alarm_GetJsonStructLogs(&log_count);
    
    // Gerekli buffer boyutunu hesapla
    size_t needed_size = 3; // [] ve null terminator
    for (uint8_t i = 0; i < log_count; i++) {
        needed_size += 50; // Temel JSON yapısı
        needed_size += strlen(logs[i].date);
        needed_size += strlen(logs[i].message);
    }
    
    char *json_buffer = malloc(needed_size);
    if (!json_buffer) {
        mg_http_reply(c, 500, headers, "{\"error\":\"Memory allocation failed\"}\n");
        return;
    }
    
    char *ptr = json_buffer;
    ptr += sprintf(ptr, "[");
    
    for (uint8_t i = 0; i < log_count; i++) {
        const char *level_str;
        switch(logs[i].level) {
            case LOG_LEVEL_INFO: level_str = "INFO"; break;
            case LOG_LEVEL_WARN: level_str = "WARN"; break;
            case LOG_LEVEL_ERROR: level_str = "ERROR"; break;
            default: level_str = "UNKNOWN"; break;
        }
        
        ptr += sprintf(ptr, "%s{\"date\":\"%s\",\"level\":\"%s\",\"message\":\"%s\"}",
                      (i > 0) ? "," : "",
                      logs[i].date,
                      level_str,
                      logs[i].message);
    }
    
    ptr += sprintf(ptr, "]");
    
    (void) hm;
    mg_http_reply(c, 200, headers, "%s\n", json_buffer);
    free(json_buffer);
}




/**
 * @brief Handles HTTP requests to download a file from the SD card.
 *
 * Extracts the 'file' parameter from the query string, checks for file existence,
 * and serves the file content as an attachment. Returns appropriate HTTP status codes for errors.
 *
 * @param[in] c  Pointer to the HTTP connection.
 * @param[in] hm Pointer to the HTTP message containing the query string.
 */
void glue_reply_download(struct mg_connection *c, struct mg_http_message *hm) {
  char file_name[128], path[256], header[256];
  struct mg_str *qs = &hm->query;

  // Extract the "file" query parameter
  mg_http_get_var(qs, "file", file_name, sizeof(file_name));
  //strcpy(file_name ,"foo.txt");
  if (file_name[0] == '\0') {
    mg_http_reply(c, 400, "Content-Type: text/plain\r\n", "Missing 'file' parameter\n");
    return;
  }

  // Build full path on SD card
  mg_snprintf(path, sizeof(path), "/sdcard/%s", file_name);

#if MG_ENABLE_POSIX_FS
  // Check file existence
  FILE *fp = fopen(path, "rb");
  if (fp == NULL) {
    mg_http_reply(c, 404, "Content-Type: text/plain\r\n", "File not found\n");
    return;
  }
  fclose(fp);
#endif

  // Set headers to force download
  mg_snprintf(header, sizeof(header), "Content-Disposition: attachment; filename=\"%s\"\r\n", file_name);
  struct mg_http_serve_opts opts = { .extra_headers = header };

  // Serve the file content
  mg_http_serve_file(c, hm, path, &opts);
}







/**
 * @brief Retrieves the current Sunday schedule structure.
 *
 * Copies the internal Sunday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a sunday structure to receive the data.
 */
void glue_get_sunday(struct sunday *data) {
  *data = s_sunday;  // Sync with your device
}



/**
 * @brief Sets the Sunday schedule structure.
 *
 * Copies the provided Sunday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a sunday structure containing schedule information.
 */
void glue_set_sunday(struct sunday *data) {
  s_sunday = *data; // Sync with your device
   printf("1\n");
}



/**
 * @brief Retrieves the current Monday schedule structure.
 *
 * Copies the internal Monday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a monday structure to receive the data.
 */
void glue_get_monday(struct monday *data) {
  *data = s_monday;  // Sync with your device
}



/**
 * @brief Sets the Monday schedule structure.
 *
 * Copies the provided Monday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a monday structure containing schedule information.
 */
void glue_set_monday(struct monday *data) {
  s_monday = *data; // Sync with your device
   printf("2\n");
}



/**
 * @brief Retrieves the current Tuesday schedule structure.
 *
 * Copies the internal Tuesday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a tuesday structure to receive the data.
 */
void glue_get_tuesday(struct tuesday *data) {
  *data = s_tuesday;  // Sync with your device
}



/**
 * @brief Sets the Tuesday schedule structure.
 *
 * Copies the provided Tuesday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a tuesday structure containing schedule information.
 */
void glue_set_tuesday(struct tuesday *data) {
  s_tuesday = *data; // Sync with your device
   printf("3\n");
}



/**
 * @brief Retrieves the current Wednesday schedule structure.
 *
 * Copies the internal Wednesday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a wednesday structure to receive the data.
 */
void glue_get_wednesday(struct wednesday *data) {
  *data = s_wednesday;  // Sync with your device
   
}



/**
 * @brief Sets the Wednesday schedule structure.
 *
 * Copies the provided Wednesday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a wednesday structure containing schedule information.
 */
void glue_set_wednesday(struct wednesday *data) {
  s_wednesday = *data; // Sync with your device
 printf("4\n");
 }



/**
 * @brief Retrieves the current Thursday schedule structure.
 *
 * Copies the internal Thursday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a thursday structure to receive the data.
 */
void glue_get_thursday(struct thursday *data) {
  *data = s_thursday;  // Sync with your device
}



/**
 * @brief Sets the Thursday schedule structure.
 *
 * Copies the provided Thursday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a thursday structure containing schedule information.
 */
void glue_set_thursday(struct thursday *data) {
  s_thursday = *data; // Sync with your device
   printf("5\n");
}




/**
 * @brief Retrieves the current Friday schedule structure.
 *
 * Copies the internal Friday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a friday structure to receive the data.
 */
void glue_get_friday(struct friday *data) {
  *data = s_friday;  // Sync with your device
}



/**
 * @brief Sets the Friday schedule structure.
 *
 * Copies the provided Friday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a friday structure containing schedule information.
 */
void glue_set_friday(struct friday *data) {
  s_friday = *data; // Sync with your device
   printf("6\n");
}



/**
 * @brief Retrieves the current Saturday schedule structure.
 *
 * Copies the internal Saturday structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a saturday structure to receive the data.
 */
void glue_get_saturday(struct saturday *data) {
  *data = s_saturday;  // Sync with your device
}



/**
 * @brief Sets the Saturday schedule structure.
 *
 * Copies the provided Saturday structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a saturday structure containing schedule information.
 */
void glue_set_saturday(struct saturday *data) {
  s_saturday = *data; // Sync with your device
  printf("7\n");
  
}



/**
 * @brief Retrieves the current holidays structure.
 *
 * Copies the internal holidays structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a holidays structure to receive the data.
 */
void glue_get_holidays(struct holidays *data) {
  *data = s_holidays;  // Sync with your device
}



/**
 * @brief Sets the holidays structure and triggers related operations.
 *
 * Copies the provided holidays structure to the internal variable,
 * sets CalendarPageRequest and StopIO_Threat flags, and prints holiday information.
 *
 * @param[in] data Pointer to a holidays structure containing holiday information.
 */
void glue_set_holidays(struct holidays *data) {
  s_holidays = *data; // Sync with your device
  CalendarPageRequest = true;
  printf("Holiday1 adi: %s\n", s_holidays.holiday1);
  printf("CalendarPageRequest=true\n");
  StopIO_Threat = true;
}



/**
 * @brief Retrieves the current network settings structure.
 *
 * Copies the internal network_settings structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a network_settings structure to receive the data.
 */
void glue_get_network_settings(struct network_settings *data) {
  *data = s_network_settings;  // Sync with your device
}


/**
 * @brief Sets the network settings structure and updates default network parameters.
 *
 * Copies the provided network_settings structure to the internal variable,
 * updates IP, gateway, and netmask information with default values,
 * disables DHCP by default, and triggers tasks for saving settings to flash.
 * Prints the updated network settings.
 *
 * @param[in] data Pointer to a network_settings structure containing network configuration.
 */
void glue_set_network_settings(struct network_settings *data) {
    s_network_settings = *data; // Sync with your device
  
    // Define edilmiş default IP bilgilerini güncelle
    snprintf(s_network_settings.ip_address, sizeof(s_network_settings.ip_address), DEVICE_WIFI_AP_IP);
    snprintf(s_network_settings.gw_address, sizeof(s_network_settings.gw_address), DEVICE_WIFI_AP_GATEWAY);
    snprintf(s_network_settings.netmask, sizeof(s_network_settings.netmask), DEVICE_WIFI_AP_NETMASK);

    // Varsayılan olarak DHCP'yi kapat
    s_network_settings.dhcp = false;
    
      // Flash’a yazma task’ını tetikle
    NetworkSettingsPageRequest = true;
    StopIO_Threat = true;

    printf("Network ayarlari guncellendi: ip=%s, gw=%s, netmask=%s, dhcp=%d\n",
            s_network_settings.ip_address,
            s_network_settings.gw_address,
            s_network_settings.netmask,
            s_network_settings.dhcp);
           
}




/**
 * @brief Begins the OTA firmware update process.
 *
 * Initiates the OTA update using the provided file size.
 * Logs the operation and returns a non-NULL pointer if successful, NULL otherwise.
 *
 * @param[in] file_name Name of the firmware file (for logging purposes).
 * @param[in] total_size Total size of the firmware file in bytes.
 * @return void* Non-NULL context pointer if OTA begins successfully, NULL otherwise.
 */
void *glue_ota_begin_firmware_update(char *file_name, size_t total_size) {
  bool ok = mg_ota_begin(total_size);
  MG_DEBUG(("%s size %lu, ok: %d", file_name, total_size, ok));
  return ok ? (void *) 1 : NULL;
}



/**
 * @brief Ends the OTA firmware update process.
 *
 * Schedules the OTA end function to be called via timer and sets the OTA done flag.
 * Always returns true.
 *
 * @param[in] context OTA context pointer (may be unused).
 * @return bool True on successful scheduling.
 */
bool glue_ota_end_firmware_update(void *context) {
  mg_timer_add(&g_mgr, 500, 0, (void (*)(void *)) (void *) mg_ota_end, context);
  isOtaDone = true;
  return true;
}




/**
 * @brief Writes a chunk of data to the OTA firmware update.
 *
 * Writes the provided buffer to the OTA update process.
 * Logs the operation for debugging purposes.
 *
 * @param[in] context OTA context pointer (may be unused).
 * @param[in] buf Pointer to the data buffer.
 * @param[in] len Number of bytes to write from the buffer.
 * @return bool True if write is successful, false otherwise.
 */
bool glue_ota_write_firmware_update(void *context, void *buf, size_t len) {
  MG_DEBUG(("ctx: %p %p/%lu", context, buf, len));
  return mg_ota_write(buf, len);
}




/**
 * @brief Retrieves the current reset structure.
 *
 * Copies the internal reset structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a reset structure to receive the data.
 */

void glue_get_reset(struct reset *data) {
  *data = s_reset;  // Sync with your device
}




/**
 * @brief Sets the reset structure and performs a full system reset.
 *
 * Copies the provided reset structure to the internal variable, clears all SD card files,
 * clears configuration data from flash, and triggers a device restart.
 *
 * @param[in] data Pointer to a reset structure containing reset information.
 */
void glue_set_reset(struct reset *data) {
  s_reset = *data; // Sync with your device
  ClearAllSDFiles();
  ClearConfigsFromFlash();
  esp_restart();
}



/**
 * @brief Retrieves the current security structure.
 *
 * Copies the internal security structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a security structure to receive the data.
 */
void glue_get_security(struct security *data) {
  *data = s_security;  // Sync with your devic
}




/**
 * @brief Sets the security structure and triggers login info update.
 *
 * Copies the provided security structure to the internal variable,
 * sets the SettingsPageLoginInfoChange flag, prints a message, and triggers IO threat stop.
 *
 * @param[in] data Pointer to a security structure containing security configuration.
 */
void glue_set_security(struct security *data) {
  s_security = *data; // Sync with your device
  SettingsPageLoginInfoChange = true;
  printf("SettingsPageLoginInfoChange=true\n");
  StopIO_Threat = true;
}




/**
 * @brief Retrieves the current clock settings structure.
 *
 * Copies the internal clock_settings structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a clock_settings structure to receive the data.
 */
void glue_get_clock_settings(struct clock_settings *data) {
  *data = s_clock_settings;  // Sync with your device
}



/**
 * @brief Sets the clock settings structure.
 *
 * Copies the provided clock_settings structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a clock_settings structure containing clock configuration.
 */
void glue_set_clock_settings(struct clock_settings *data) {
  s_clock_settings = *data; // Sync with your device
}




/**
 * @brief Retrieves the current system information structure.
 *
 * Copies the internal systemInfo structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a systemInfo structure to receive the data.
 */
void glue_get_systemInfo(struct systemInfo *data) {
  *data = s_systemInfo;  // Sync with your device
}



/**
 * @brief Sets the system information structure and triggers system info update.
 *
 * Copies the provided systemInfo structure to the internal variable,
 * sets the SettingsPageSystemInfoRequest flag, prints a message, and triggers IO threat stop.
 *
 * @param[in] data Pointer to a systemInfo structure containing system information.
 */
void glue_set_systemInfo(struct systemInfo *data) {
  s_systemInfo = *data; // Sync with your device
  SettingsPageSystemInfoRequest = true;
  printf("SettingsPageSystemInfoRequest=true\n");
  StopIO_Threat = true;
  printf(("systemInfo\n"));
}




/**
 * @brief Retrieves the current Wi-Fi settings structure.
 *
 * Copies the internal wifiSettings structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a wifiSettings structure to receive the data.
 */
void glue_get_wifiSettings(struct wifiSettings *data) {
  *data = s_wifiSettings;  // Sync with your device
}



/**
 * @brief Sets the Wi-Fi settings structure and triggers Wi-Fi settings update.
 *
 * Copies the provided wifiSettings structure to the internal variable,
 * sets the SettingsPageWifiSettingsRequest flag, prints a message, and triggers IO threat stop.
 *
 * @param[in] data Pointer to a wifiSettings structure containing Wi-Fi configuration.
 */
void glue_set_wifiSettings(struct wifiSettings *data) {
  s_wifiSettings = *data; // Sync with your device
  //wifi_deinit_ap();
  SettingsPageWifiSettingsRequest = true;
  printf("SettingsPageWifiSettingsRequest=true\n");
  StopIO_Threat = true;
}



/**
 * @brief Retrieves the current default configuration structure.
 *
 * Copies the internal defaultConfiguration structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a defaultConfiguration structure to receive the data.
 */
void glue_get_defaultConfiguration(struct defaultConfiguration *data) {
  *data = s_defaultConfiguration;  // Sync with your device
}




/**
 * @brief Sets the default configuration structure.
 *
 * Copies the provided defaultConfiguration structure to the internal variable for synchronization.
 * Prints an informational message.
 *
 * @param[in] data Pointer to a defaultConfiguration structure containing default configuration.
 */
void glue_set_defaultConfiguration(struct defaultConfiguration *data) {
s_defaultConfiguration = *data; // Sync with your device
printf(("1\n")); 
}



/**
 * @brief Retrieves the current alternative 1 configuration structure.
 *
 * Copies the internal alt1Configuration structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to an alt1Configuration structure to receive the data.
 */
void glue_get_alt1Configuration(struct alt1Configuration *data) {
  *data = s_alt1Configuration;  // Sync with your device
}



/**
 * @brief Sets the alternative 1 configuration structure and triggers flash write.
 *
 * Copies the provided alt1Configuration structure to the internal variable,
 * sets the Alt1ConfigFlashWrite flag, and prints informational messages.
 *
 * @param[in] data Pointer to an alt1Configuration structure containing configuration.
 */
void glue_set_alt1Configuration(struct alt1Configuration *data) {
s_alt1Configuration = *data; // Sync with your device
printf("Alt1ConfigFlashWrite=true\n");
Alt1ConfigFlashWrite = true;
printf(("2\n"));
}




/**
 * @brief Retrieves the current alternative 2 configuration structure.
 *
 * Copies the internal alt2Configuration structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to an alt2Configuration structure to receive the data.
 */
void glue_get_alt2Configuration(struct alt2Configuration *data) {
  *data = s_alt2Configuration;  // Sync with your device
}




/**
 * @brief Sets the alternative 2 configuration structure and triggers flash write.
 *
 * Copies the provided alt2Configuration structure to the internal variable,
 * sets the Alt2ConfigFlashWrite flag, and prints informational messages.
 *
 * @param[in] data Pointer to an alt2Configuration structure containing configuration.
 */
void glue_set_alt2Configuration(struct alt2Configuration *data) {
s_alt2Configuration = *data; // Sync with your device
Alt2ConfigFlashWrite = true;
printf("Alt2ConfigFlashWrite=true\n");
printf(("3\n"));
}





/**
 * @brief Retrieves the current alternative 3 configuration structure.
 *
 * Copies the internal alt3Configuration structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to an alt3Configuration structure to receive the data.
 */
void glue_get_alt3Configuration(struct alt3Configuration *data) {
  *data = s_alt3Configuration;  // Sync with your device
}



/**
 * @brief Sets the alternative 3 configuration structure and triggers configuration update.
 *
 * Copies the provided alt3Configuration structure to the internal variable,
 * sets the ConfigurationPageRequest flag, prints a message, and triggers IO threat stop.
 *
 * @param[in] data Pointer to an alt3Configuration structure containing configuration.
 */
void glue_set_alt3Configuration(struct alt3Configuration *data) {
s_alt3Configuration = *data;
  ConfigurationPageRequest = true;
  printf("ConfigurationPageRequest=true\n");
  StopIO_Threat = true; 
}




/**
 * @brief Replies with a JSON array of .wav files in the mounted directory over HTTP.
 *
 * Scans the directory specified by MOUNT_POINT for .wav files, calculates the required buffer size,
 * allocates memory, and fills the buffer using CheckSDFiles. Sends the buffer contents in a JSON HTTP response.
 * Handles errors for directory opening and memory allocation gracefully.
 *
 * @param[in] c  Pointer to the HTTP connection.
 * @param[in] hm Pointer to the HTTP message (unused).
 */
void glue_reply_directory(struct mg_connection *c, struct mg_http_message *hm) {
    const char *headers = "Cache-Control: no-cache\r\n"
                         "Content-Type: application/json\r\n"
                         "Access-Control-Allow-Origin: *\r\n";

    // İlk geçiş: Gerekli buffer boyutunu hesapla
    size_t needed_size = 3; // "[]\0" için temel boyut
    
    // Geçici buffer kullanarak boyut hesapla
    char temp_buffer[256];
    DIR *dir = opendir(MOUNT_POINT);
    if (dir == NULL) {
        mg_http_reply(c, 500, headers, "{\"error\":\"Failed to open directory\"}\n");
        return;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        char *ext = strrchr(entry->d_name, '.');
        if (ext && strcasecmp(ext, ".wav") == 0) {
            // Her giriş için tahmini boyut
            needed_size += 50 + strlen(entry->d_name) + 20;
        }
    }
    closedir(dir);

    // Buffer ayır
    char *json_buffer = malloc(needed_size);
    if (!json_buffer) {
        mg_http_reply(c, 500, headers, "{\"error\":\"Memory allocation failed\"}\n");
        return;
    }
    // CheckSDFiles fonksiyonunu çağır
    CheckSDFiles(json_buffer, needed_size);
    // Yanıtı gönder
    mg_http_reply(c, 200, headers, "%s\n", json_buffer);
    free(json_buffer);
    (void)hm; // Kullanılmayan parametre uyarısını önle
}



/**
 * @brief Retrieves the current playSound structure.
 *
 * Copies the internal playSound structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a playSound structure to receive the data.
 */
void glue_get_playSound(struct playSound *data) {
  *data = s_playSound;  // Sync with your device 
}





/**
 * @brief Sets the playSound structure and configures playback parameters.
 *
 * Copies the provided playSound structure to the internal variable, sets flags for stopping playback and test mode,
 * calculates the volume factor, and prints file and volume information.
 *
 * @param[in] data Pointer to a playSound structure containing sound playback information.
 */
void glue_set_playSound(struct playSound *data) {
  s_playSound = *data; // Sync with your device
  StopPlayWav = true;
  TestMode = true;

  volume_factor = (float)s_playSound.soundLevel * (0.55f / 100.0f);
  printf("volume_factor degeri: %.2f\n", volume_factor);
  printf("Volume degeri: %d\n", s_playSound.soundLevel);
  printf("Dosya adi: %s\n", s_playSound.fileName);
 
}




/**
 * @brief Retrieves the current audio configuration structure.
 *
 * Copies the internal audioConfig structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to an audioConfig structure to receive the data.
 */
void glue_get_audioConfig(struct audioConfig *data) {
  *data = s_audioConfig;  // Sync with your device
}



/**
 * @brief Sets the audio configuration structure and triggers audio configuration update.
 *
 * Copies the provided audioConfig structure to the internal variable for synchronization.
 * Sets the AudioConfigurationPageRequest flag, prints a message, and triggers IO threat stop.
 * (Optionally, you can uncomment the print statements to display all sound member values.)
 *
 * @param[in] data Pointer to an audioConfig structure containing audio configuration.
 */
void glue_set_audioConfig(struct audioConfig *data) {
   s_audioConfig = *data; // Sync with your device
//    // Print all structure members
//    printf("sound30: %s\n", s_audioConfig.sound30);
//    printf("sound29: %s\n", s_audioConfig.sound29);
//    printf("sound28: %s\n", s_audioConfig.sound28);
//    printf("sound27: %s\n", s_audioConfig.sound27);
//    printf("sound26: %s\n", s_audioConfig.sound26);
//    printf("sound25: %s\n", s_audioConfig.sound25);
//    printf("sound24: %s\n", s_audioConfig.sound24);
//    printf("sound23: %s\n", s_audioConfig.sound23);
//    printf("sound22: %s\n", s_audioConfig.sound22);
//    printf("sound21: %s\n", s_audioConfig.sound21);
//    printf("sound20: %s\n", s_audioConfig.sound20);
//    printf("sound19: %s\n", s_audioConfig.sound19);
//    printf("sound18: %s\n", s_audioConfig.sound18);
//    printf("sound17: %s\n", s_audioConfig.sound17);
//    printf("sound16: %s\n", s_audioConfig.sound16);
//    printf("sound15: %s\n", s_audioConfig.sound15);
//    printf("sound14: %s\n", s_audioConfig.sound14);
//    printf("sound13: %s\n", s_audioConfig.sound13);
//    printf("sound12: %s\n", s_audioConfig.sound12);
//    printf("sound11: %s\n", s_audioConfig.sound11);
//    printf("sound10: %s\n", s_audioConfig.sound10);
//    printf("sound9: %s\n", s_audioConfig.sound9);
//    printf("sound8: %s\n", s_audioConfig.sound8);
//    printf("sound7: %s\n", s_audioConfig.sound7);
//    printf("sound6: %s\n", s_audioConfig.sound6);
//    printf("sound5: %s\n", s_audioConfig.sound5);
//    printf("sound4: %s\n", s_audioConfig.sound4);
//    printf("sound3: %s\n", s_audioConfig.sound3);
//    printf("sound2: %s\n", s_audioConfig.sound2);
//    printf("sound1: %s\n", s_audioConfig.sound1);
   printf("AudioConfigurationPageRequest=true\n");
   AudioConfigurationPageRequest = true;
   StopIO_Threat = true;
}




/**
 * @brief Retrieves the current time and date from the device.
 *
 * Formats the date and time from DeviceTime and copies it to the provided currentTime structure.
 *
 * @param[out] data Pointer to a currentTime structure to receive the formatted date and time.
 */
void glue_get_currentTime(struct currentTime *data) {
	// DeviceTime'dan tarih ve saati formatla
  snprintf(s_currentTime.date, sizeof(s_currentTime.date), 
           "%02d.%02d.20%02d", 
           DeviceTime.day, DeviceTime.month, DeviceTime.year);

  snprintf(s_currentTime.time, sizeof(s_currentTime.time), 
           "%02d:%02d:%02d", 
           DeviceTime.hours, DeviceTime.minutes, DeviceTime.seconds);

  *data = s_currentTime;  // Sync with your device
  
}





/**
 * @brief Sets the current time and date on the device.
 *
 * Saves the received currentTime structure, parses the date and time fields,
 * updates DeviceTime, calculates the day of the week, and writes to the RTC.
 * Logs an error if RTC write fails.
 *
 * @param[in] data Pointer to a currentTime structure containing the new date and time.
 */
void glue_set_currentTime(struct currentTime *data) {
    s_currentTime = *data;  // JSON'dan gelen zamanı kaydet

    // s_currentTime -> DeviceTime aktar
    uint16_t full_year;
	sscanf(s_currentTime.date, "%hhu.%hhu.%hu", &DeviceTime.day, &DeviceTime.month, &full_year);
	DeviceTime.year = full_year % 100;  // 2025 -> 25

    sscanf(s_currentTime.time, "%hhu:%hhu:%hhu", &DeviceTime.hours, &DeviceTime.minutes, &DeviceTime.seconds);

     // Otomatik olarak haftanın gününü hesapla
    struct tm t = {0};
    t.tm_year = full_year - 1900; // tm_year 1900'den beri geçen yılları tutar
    t.tm_mon = DeviceTime.month - 1; // tm_mon 0-11 arasındadır
    t.tm_mday = DeviceTime.day;
    // mktime() fonksiyonu tm yapısını doldurur, buna tm_wday (haftanın günü) de dahildir.
    mktime(&t); 
    // Haftanın gününü RTC formatına çevir (0: Pazar, 1: Pazartesi...)
    DeviceTime.day_of_week = t.tm_wday; 
    
    // RTC'ye yaz
    esp_err_t result = mcp7940n_set_time(&DeviceTime);
    if (result != ESP_OK) {
        Alarm_Log("glue_set_currentTime: RTC ayarlanamadi", NULL);
    }
}





/**
 * @brief Replies with the noise level history as a JSON array over HTTP.
 *
 * Constructs a JSON array from the noise_level_history and sends it as an HTTP response.
 * Handles buffer overflow and ensures valid JSON formatting.
 *
 * @param[in] c  Pointer to the HTTP connection.
 * @param[in] hm Pointer to the HTTP message (unused).
 */
void glue_reply_noiseLevel(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  char response_buffer[256]; // Ensure sufficient size
  char *ptr = response_buffer;
  size_t remaining_size = sizeof(response_buffer);
  int written_chars; 
      // JSON array start
      written_chars = snprintf(ptr, remaining_size, "[");
      if (written_chars < 0 || (size_t)written_chars >= remaining_size) {
          mg_http_reply(c, 200, headers, "[]\n");
           return;
      }
      ptr += written_chars;
      remaining_size -= written_chars;

      // Iterate through the history array and build JSON
      for (int i = 0; i < NOISE_LEVEL_HISTORY_SIZE; i++) {
          if (i > 0) {
              written_chars = snprintf(ptr, remaining_size, ",");
              if (written_chars < 0 || (size_t)written_chars >= remaining_size) break;
              ptr += written_chars;
              remaining_size -= written_chars;
          }

          written_chars = snprintf(ptr, remaining_size, "\"%d\"", noise_level_history[i]);
          if (written_chars < 0 || (size_t)written_chars >= remaining_size) break;
          ptr += written_chars;
          remaining_size -= written_chars;
      }

      // JSON array end
      if (remaining_size > 0) {
          snprintf(ptr, remaining_size, "]");
      } else {
          // Fallback for full buffer: try to terminate correctly
          if (sizeof(response_buffer) > 0) {
              if (ptr > response_buffer && *(ptr - 1) == ',') {
                  *(ptr - 1) = ']';
                  *ptr = '\0';
              } else {
                  response_buffer[sizeof(response_buffer) - 1] = '\0';
              }
          }
      } 
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", response_buffer);
}





/**
 * @brief Retrieves the current volume structure.
 *
 * Calculates the volume from the volume_factor and copies it to the provided pointer.
 *
 * @param[out] data Pointer to a volume structure to receive the data.
 */
void glue_get_volume(struct volume *data) {
s_volume.volume = (int)((volume_factor / 0.55f) * 150.0f + 0.5f);
*data = s_volume;  // Sync with your device
}





/**
 * @brief Sets the volume structure.
 *
 * Copies the provided volume structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a volume structure containing volume information.
 */
void glue_set_volume(struct volume *data) {
  s_volume = *data; // Sync with your device
}




/**
 * @brief Retrieves the current device status structure.
 *
 * Copies the internal deviceStatus structure to the provided pointer for synchronization.
 *
 * @param[out] data Pointer to a deviceStatus structure to receive the data.
 */
void glue_get_deviceStatus(struct deviceStatus *data) {
  *data = s_deviceStatus;  // Sync with your device
}





/**
 * @brief Sets the device status structure.
 *
 * Copies the provided deviceStatus structure to the internal variable for synchronization.
 *
 * @param[in] data Pointer to a deviceStatus structure containing status information.
 */
void glue_set_deviceStatus(struct deviceStatus *data) {
  s_deviceStatus = *data; // Sync with your device
}


